---
title: "talk03 练习与作业"
documentclass: ctexart
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 2
  word_document: default
  html_document:
    df_print: paged
knit: (
  function(inputFile, encoding) { 

    pSubTitle <- '\u674e\u7ecf\u7eac-U201912387-talk03-homework'

    rmarkdown::render( 
      input       = inputFile, 
      encoding    = encoding, 
      params      = list(sub_title = pSubTitle),      
      output_file = pSubTitle) })
---

## 练习和作业说明

将相关代码填写入以 \`\`\`{r} \`\`\` 标志的代码框中，运行并看到正确的结果；

完成后，用工具栏里的"Knit"按键生成PDF文档；

**将生成的PDF**改为：**`姓名-学号-talk03作业.pdf`**，并提交到老师指定的平台/钉群。

## talk03 内容回顾

-   二维表：`data.frame`, `tibble`

    -   声明

    -   操作

        -   增减行、列

        -   合并

    -   常用相关函数

        -   `nrow`, `ncol`, `dim` , `str` , `head`, `tail`

    -   `data.frame`和 `tibble` 的不同

    -   高级技巧：

        -   `with`, `within`

-   IO

    -   系统自带函数

    -   `readr` 带的函数

    -   不同格式的读取

    -   从网络、压缩文件读取

## 练习与作业1，`data.frame`

注：以下内容来自 <https://www.r-exercises.com/>。

-   **生成下面的 `data.frame` 的前三列，之后再增加 `Sex` 这列**

![](images/table1.png){width="80%"}

```{r}
## 先生成前三列；
row_names<-c('Alex','Lilly','Mark','Oliver','Martha','Lucas','Caroline')
Age<-c(25,31,23,52,76,49,26)
Height<-c(177,163,190,179,163,183,164)
Weight<-c(57,69,83,75,70,83,53)
df_1<-data.frame(Age=Age,Height=Height,Weight=Weight)
rownames(df_1)<-row_names
df_1
## 再插入第四列
Sex<-c('F','F','M','M','F','M','F')
df_1<-cbind(df_1,Sex)
## 显示最终结果
df_1
```

------------------------------------------------------------------------

-   **生成以下`data.frame`，确保`Working`这列的类型是 `character`，而不是 `factor`**

![](images/table2.png){width="80%"}

```{r}
## 生成 data.frame
row_names<-c('Alex','Lilly','Mark','Oliver','Martha','Lucas','Caroline')
Working<-c('Yes','No','No','Yes','Yes','No','Yes')
df_2<-data.frame(Working=Working)
row.names(df_2)=row_names
## 显示结果
df_2
## 显示 Working 列的性质
cat('Working这一列的性质为：',class(df_2$Working))
```

------------------------------------------------------------------------

-   **检查系统自带变量 `state.center` 的内容，将其转化为 `data.frame`**

```{r}
## 代码写这里，并运行；
state.center
str(state.center)
(as.data.frame(state.center))
```

------------------------------------------------------------------------

-   **生成一个 50行 \* 5列 的`matrix`，将其行名改为：row_i 格式，其中 i 为当前的行号，比如 row_1, row_2 等**

```{r}
## 代码写这里，并运行；
matrix_1<-matrix(1:250, 50, 5)
row_names=NULL
for (i in 1:50){
  row_names<-c(row_names,paste('row_',as.character(i),sep = ''))
}
row.names(matrix_1)<-row_names
matrix_1
```

------------------------------------------------------------------------

-   **使用系统自带变量`VADeaths`，做如下练习：**

-   检查`VADeaths`的类型，如果不是 `data.frame`，则转换之；

-   添加新的一列，取名 `Total`，其值每行的总合

-   调整列的顺序，将 `Total` 变为第一列。

```{r}
## 代码写这里，并运行；
class(VADeaths)
if(class(VADeaths)[1]!='data.frame')
{
  cat('VADeaths 的类型不是data.frame，现进行转换')
  new_VADeaths<-as.data.frame(VADeaths)
}else
{
  new_VADeaths<-VADeaths
}
new_VADeaths
Total<-apply(new_VADeaths,1,sum)
cat('\n行和为：',Total)
new_VADeaths<-cbind(Total,new_VADeaths)
new_VADeaths
```

------------------------------------------------------------------------

-   **用系统自带的`swiss`数据做练习：**

-   取子集，选取第1, 2, 3, 10, 11, 12 and 13行，第`Examination`, `Education` 和 `Infant.Mortality`列；

-   将`Sarine`行 `Infant.Mortality` 列的值改为NA；

-   增加一列，命名为 `Mean`，其值为当前行的平均值；

```{r}
## 代码写这里，并运行；
cat('原始swiss如下\n')
swiss
tar_row<-c(1,2,3,10,11,12,13)
tar_col<-c('Examination','Education','Infant.Mortality')
cat('取完子集后\n')
new_swiss<-swiss[tar_row,tar_col]
new_swiss
cat('按题意修改后：\n')
new_swiss['Sarine','Infant.Mortality']<-NA
new_swiss
cat('增加一列Mean后')
Mean<-apply(new_swiss, 1, mean)
new_swiss<-cbind(new_swiss,Mean)
new_swiss
```

------------------------------------------------------------------------

-   **将下面三个变量合并生成一个`data.frame`**

`Id <- LETTERS`

`x <- seq(1,43,along.with=Id)`

`y <- seq(-20,0,along.with=Id)`

```{r}
## 代码写这里，并运行；
Id <- LETTERS
x <- seq(1,43,along.with=Id)
y <- seq(-20,0,along.with=Id)
df_3<-data.frame(Id=Id,x=x,y=y)
df_3
```

**问：** `seq`函数中的`along.with` 参数的意义是什么？请举例说明。

答：seq函数的目的时返回一个from to的向量，along.with是对于这个向量返回值的一个参数

官方文档提到的是along.with take the length from the length of this argument. 也就是说使生成的向量的长度与along.with这个参数的长度一致，并且没有其他特别要求的情况下，以等步长的形式生成该向量

简单地说，along.with表示产生的等间隔数列与向量具有相同的长度

举例如下

a为1，2，3，...，10，长度为10，在指定along.with=a的时候，创建出来的b c的长度均为10

而在不指定along.with=a的时候，b_的值为从2到20以1为步长的所有值，长度为19，可见along.with的作用就是产生等间隔数列，且该向量与along.with的参数向量长度一致

```{r}
## 代码写这里，并运行；
a<-1:10
b<-seq(2,20,along.with=a)
b_<-seq(2,20)
c<-seq(0,100,along.with=a)
a
b
b_
c
df_temp<-data.frame(a,b,c)
df_temp
```

------------------------------------------------------------------------

-   **提供代码，合并以下两个 `data.frame`**

<!-- -->

    > df1 的内容 
    Id Age
    1 14
    2 12
    3 15
    4 10 

    >df2 的内容
    Id Sex Code
    1 F a
    2 M b
    3 M c
    4 F d

合并之后的结果：

    > M 
    Id Age Sex Code
    1 14 F a
    2 12 M b
    3 15 M c
    4 10 F d

```{r}
## 代码写这里，并运行；
Id<-1:4
Age<-c(14,12,15,10)
Sex<-c('F','M','M','F')
Code<-c('a','b','c','d')
df1<-data.frame(Id=Id,Age=Age)
df1
df2<-data.frame(Id,Sex,Code)
df2
M<-merge(df1,df2)
M
```

------------------------------------------------------------------------

-   **从上面的`data.frame`中删除`code`列**

```{r}
## 代码写这里，并运行；
M<-subset(M,select=-Code)
M
```

------------------------------------------------------------------------

-   **练习，回答代码中的问题**

<!-- -->

    ## 1. 生成一个10 行2 列的data.frame
    df3 <- data.frame( data = 1:10, group = c("A","B") );
    ## 2. 增加一列，其长度是1，可以吗？
    cbind(df3, newcol = 1);
    ## 3. 增加一列，其长度是10，可以吗？
    cbind(df3, newcol = 1:10);
    ## 4. 增加一列，其长度是2，可以吗？
    cbind(df3, newcol = 1:2);
    ## 5. 增加一列，其长度是3，可以吗？
    cbind(df3, newcol = 1:3);

```{r}
## 代码写这里，并运行；
df3 <- data.frame( data = 1:10, group = c("A","B") )
df3
cbind(df3, newcol = 1);
cbind(df3, newcol = 1:10);
cbind(df3, newcol = 1:2);
# cbind(df3, newcol = 1:3);
```

答：通过运行代码，可以发现

2.  增加一列，其长度是1； 3. 增加一列，其长度是10； 4. 增加一列，其长度是2 这三个是可以的，因为其长度正好是行数可以整除的数：10/1=10；10/10=1；10/2=5，可以完成并行计算或者说循环补齐

但5. 增加一列，其长度是3 这一条不行，出现报错

Error in data.frame(..., check.names = FALSE) : 参数值意味着不同的行数: 10, 3

因为其长度不是行数可以整除的数：10/3=3......1，无法正常完成循环计算、并行计算

## 练习与作业2，`tibble`

-   **运行以下代码，生成一个新的`tibble`：**

```{r}
## 如果系统中没有 lubridate 包，则安装：
if (!require("lubridate")){ 
  chooseCRANmirror();
  install.packages("lubridate");
} 
library(lubridate);

if (!require("tibble")){ 
  chooseCRANmirror();
  install.packages("tibble");
}
library(tibble);

tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)
```

从中可以看出，`tibble`支持一些细分数据类型，包括：

-   `<dttm>`
-   `<date>`
-   还有int dbl chr lgl fctr
-   以上分别表示：日期+时间；日期；integer；double；character；逻辑数据类型；代表因子类型

等；

------------------------------------------------------------------------

-   **生成一个如下的`tibble`，完成以下任务：**

<!-- -->

    df <- tibble(
      x = runif(5),
      y = rnorm(5)
    )

任务：

-   取一列，比如`x`这一列，得到一个 `tibble`；
-   取一列，比如`y`这一列，得到一个 `vector`；

```{r}
## 代码写这里，并运行；
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
str(df)
df
tb1<-as_tibble(df['x'])
cat('tb1的数据类型为tibble T/F',is_tibble(tb1),'\n')
tb1
tb2<-df[['y']]
# 通过查找，发现也可以用先转换为matrix在转换为vector的方法
# 代码如下
# tb2<-as.matrix(tb2[,'y'])
# tb2<-as.vector(tb2)
cat('tb2的数据类型为vector T/F',is.vector(tb2),'\n')
tb2
```

------------------------------------------------------------------------

-   **用 `tibble` 函数创建一个新的空表，并逐行增加一些随机的数据，共增加三行：**

```{r}
## 代码写这里，并运行；
## 新tibble, with defined columns ... 创建表头
tb <- tibble( name = character(), age = integer(), salary = double() );
##增加三行随机数据；
tb<-add_row(tb,name=sample(LETTERS,3),
            age=sample(30:50,3),
            salary=sample(3000:5000,3))
tb
```

------------------------------------------------------------------------

-   \*\* 请解释为什么下面第一行代码能够运行成功，但第二个不行？ \*\*

这个可以：

`data.frame(a = 1:6, b = LETTERS[1:2]);`

但下面这个不行：

`tibble(a = 1:6, b = LETTERS[1:2]);`

问：为什么？tibble 循环的规则是什么？

答：因为tibble的recycling仅限于长度为1或等长；而data.frame则为整除即可，

所以对于`data.frame(a = 1:6, b = LETTERS[1:2])`是可以运行的，因为6/2=3，可以整除，然后循环补齐即可

而对于`tibble(a = 1:6, b = LETTERS[1:2]);`是不行的，因为b的长度为2，相当于要要循环的长度不为1，而是2，同时a的长度是6，二者也不等长，所以是不行的

------------------------------------------------------------------------

-   **`attach`和`detach`：**

问：这个两个函数的用途是什么？请用 `iris` 这个系统自带变量举例说明。

答：attach函数的用法如下：

attach(what, pos = 2L, name = deparse(substitute(what), backtick=FALSE),

warn.conflicts = TRUE)

CSDN上找到的说法如下：

1.attach()是对what添加路径索引，避免重复输入what名称，参数解释如下：

what：数据框或列表；

pos=2L：添加的路径存储的位置，一般默认即可。在对多个数据添加索引时，此位置会变成3L,4L,5L...detach()撤销索引路径时，会撤销对应位置的索引储存，具体例子见后；

name：不懂，遇见需要的情况再补充；

backtick=FALSE：反引号，经过测试，该参数固定为FALSE不可调，再调用索引时会用到；

warn.conflicts：是否打印警告。

2.**detach()**是撤销attach()建立的路径索引，往往二者配套使用。

简单地说，按个人理解，attach()就是使括号内的参数添加到环境变量，使其内的内容可以直接被调用，而不用通过 \$ 来引用；detach就可以认为是attach()的逆操作，也就是说将该参数从环境变量中删除，使其内的参数不能直接被调用，需要用 \$ 才能调用

举例如下，可以发现，如果不用attach，就必须用iris\$Sepal.Width，而如果用attach，将会弹出iris的列名，并且直接用列名操作即可，不需要用iris\$

```{r}
head(iris,n=5);
head(iris$Sepal.Width,n=5)
attach(iris)
  head(Sepal.Width,n=5)
detach(iris)
```

------------------------------------------------------------------------

-   **使用内置变量`airquality`：**

-   检查它是否是 `tibble`；

-   如果不是，转化为 `tibble`；

```{r}
## 代码写这里，并运行；
if (class(airquality)[1]=='tibble'){
  cat('airquality 的类型是tibble，不用转换')
}else
{
  cat('airquality 的类型不是tibble，需要转换\n')
  tibble_airquality=as_tibble(airquality)
}
class(airquality)
str(tibble_airquality)
```

------------------------------------------------------------------------

-   **问：`tibble::enframe`函数的用途是什么？请举例说明：**

答：官方文档Help给出来的说法是：Converting vectors to data frames, and vice versa. 更详细的说法是：enframe() converts named atomic vectors or lists to one- or two-column data frames. For a list, the result will be a nested tibble with a column of type list. For unnamed vectors, the natural sequence is used as name column. 简单地说，就是将一个vector或者list转变成一列或两列的data frames

举例如下

```{r}
l<-list(a=sample(1:10,3),b=sample(1:10,3))
l
l_tb<-tibble::enframe(l)
l_tb
```

------------------------------------------------------------------------

-   **简述`tibble`相比`data.frame`的优势？并用实例展示**

答：tibble对data.frame做了重新的设定：

1.  不关心输入类型，可存储任意类型，包括list

2.  支持任意的列名，会自动添加列名

3.  会懒加载参数，并且按顺序运行，或者说tibble evaluates columns sequentially

4.  对于subset操作，tibble不会造成困扰

5.  tibble可以进行可控的数据类型转换

    个人认为也有缺点，比如tibble的recycling仅限于长度为1或登场，而data.frame则为整除即可

    另外，data.frame可以实现部分匹配，而tibble不可以

    劣势就不做展示了

```{r}
## 代码写这里，并运行；
cat('对于前两条优势，可以用之前题目中出现过的代码展示')
tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)
cat('对于第三条，可以用PDF的代码展示')
tibble(x=1:5,y=x^2)
cat('对于第四条，可以用PDF的代码展示')
df1 <- data.frame(x = 1:3, y = 3:1);
class(df1[, 1:2]);
class(df1[, 1]);  #会得到一个vector...
df2 <- tibble(x = 1:3, y = 3:1);
class(df2[, 1]);  #永远得到的都是tibble
cat('对于第五条，可以用PDF的代码展示')
class(df2[[1]]); ## 取一列，转换为vector
class(df2$x); ## 用[[]] 或$ 都可以哦
```

## 练习与作业3：IO

-   **提供代码，正确读取以下文件：**

注：数据在当前目录下的 `data/` 子目录里

-   Table0.txt
-   Table1.txt
-   Table2.txt
-   Table3.txt
-   Table4.txt
-   Table5.txt
-   Table6.txt
-   states1.csv
-   states2.csv

注2：每个文件读取需要提供两种方法，一种是利用系统自带函数，另一种是`readr`包的函数；

```{r}
## 用系统自带函数，并显示读取的内容；
read.csv('data/Table0.txt')
read.csv('data/Table1.txt')
read.csv('data/Table2.txt')
read.csv('data/Table3.txt')
read.csv('data/Table4.txt')
read.csv('data/Table5.txt')
read.csv('data/Table6.txt')
read.csv('data/states1.csv')
read.csv('data/states2.csv',header = F)
## 用readr 包的函数读取，并显示读取的内容；
library(readr)
read_csv('data/Table0.txt')
read_csv('data/Table1.txt')
read_csv('data/Table2.txt')
read_csv('data/Table3.txt')
read_csv('data/Table4.txt')
read_csv('data/Table5.txt')
read_csv('data/Table6.txt')
read_csv('data/states1.csv')
read_csv('data/states2.csv')

```
